# Компонент "Расписание"
На данном занятии мы создадим свой компонент для отображения расписания занятий. После, мы применим к нему стили, что бы он красиво выглядел.

Мы уже создали заготовки файлов для данного компонента. Откройте в редакторе кода путь `src/components/schedule` в проекте. Там вы увидите 3 файла:
- `index.js` - здесь будет хранится основной компонент
- `day-schedule.js` - здесь мы создадим компонент, который будет строить отображение для расписания каждого дня
- `lesson.js` - здесь мы создадим компонент, который будет строить отображение для каждого занятия

Для описания компонентов мы использовали более короткий вид объявления функции - `arrow function`. Я бы советовал так и продолжать использовать, но если вам хочется, вы всегда можете использовать обычные, именованные функции.

```javascript
// оба примера эквивалентны
const test = () => true; // arrow function

function test() { // классическая функция
    return true;
}
```

## Немного теории
Для правильного построения приложения в библиотеке `React Native` есть несколько уже готовых компонентов и объектов.

### Text
Самый простой компонент. Он создан для отображения текста. Другие компоненты не могут отображать текст, пока они не будут использовать данный компонент.
```jsx
<Text>Привет, мир!</Text>
```

### View
Компонент `View` служит для того, что бы организовывать компоненты внутри себя. Он может, например, расположить компоненты по вертикали или горизонтали, или отцетрировать их.
```jsx
<View>
    <Text>Элемент 1</Text>
    <Text>Элемент 2</Text>
    <Text>Элемент 3</Text>
</View>
```

### ScrollView
Это расширение компонента `View`, который помимо организации компонентов умеет еще и прокручиваться при соответствующем движении пальцем.
```jsx
<ScrollView>
    <Text>Элемент 1</Text>
    <Text>Элемент 2</Text>
    <Text>Элемент 3</Text>
</ScrollView>
```

### StyleSheet
`StyleSheet` не является компонентом. На самом деле это обычный `JavaScript` объект, в котором находятся функции-помощники.
На нашем занятии нас будет интересовать лишь 2 его функции.

#### create
Данная функция помощник создает группированные стили, что бы можно было их использовать в компоненте. Помимо создания группировки, она еще оптимизирует использование стилей: если использовать `StyleSheet.create`, то у вас приложение будет работать быстрее, чем если не использовать (зависит от приложения, конечно же).
```jsx
const styles = StyleSheet.create({
    wrapper: {
        height: 50,
        backgroundColor: 'white',
    },
    text: {
        fontSize: 24,
    }
});

const Component = () => <View style={ styles.wrapper }><Text style={ styles.text }>text</Text></View>;
```

#### flatten
Данная функция помощник позволяет использовать несколько групп стилей на одном компоненте.
```jsx
const styles = StyleSheet.create({
    wrapper: {
        height: 50,
        backgroundColor: 'white',
    },
    highlighted: {
        backgroundColor: 'yellow',
    }
});

const Component = () => (
    <View style={ StyleSheet.flatten([styles.wrapper, styles.highlighted]) }>
        <Text>text</Text>
    </View>
);
```

Обратите внимание, что в примерах используются фигурные скобки `{}`. Это необходимо для JSX, что бы понимать, что это не статичный текст, а переменная.


## Предварительная подготовка:

Перед началом создания наших компонентов давайте убедимся, что все работает:
> Откройте файл `src/components/schedule/index.js`

На данный момент функция `Schedule` возвращает нам `null` давайте заменим это значение на `ScrollView` заменив `null` на пример с использованием этого элемента, показанный выше. Открыв мобильное приложение мы должны увидеть календарь, который был написан заранее и три строчки с текстом `Элемент 1/2/3`

Теперь, давайте разберемся со структурой нашего приложения. Она будет соответствовать нашему расписанию и выглядеть следующим образом:

`index.js` - файл где мы сейчас работали является компонентом Расписание или `Schedule`
`day-schedule.js` - будет отвечать за расписание на сегодняшний день и является `DaySchedule` компонентом
и наконец `lesson.js` является компонентом Занятие или `Lesson`

Нашей задачей будет наполнить эти компоненты данными и связать их друг с другом.
Условно это будет выглядеть следующим образом: `Schedule -> DaySchedule -> Lesson`

т.е. мы будем передавать данные от `Schedule` компонента(будет являться родительским компоненом) в `DaySchedule` (дочерний компонент для `Schedule`), который в свою очередь будет передавать данные в компонент `Lesson`

Но как же связать эти компоненты друг с другом?

На смом деле этот вопрос давно решен `React` и выглядит следующим образом: 

Так как наши компоненты являются функциями, то нашей задачей будет передать данные от родительских компонентов дочерним, которые будут примниматься как аргументы функции, которые мы и будем в них использовать.

Давайте же посмотрим как это делается на практике:

```jsx
const ChildrenComponent = (props) => {
    props.index === 1 // true
    props.key === 2   // true
    
    // ... 
}

const ParentComponent = () => {
    const args = {
        index: 1
    }

    const keyValue = 2

    return <ChildComponent index={args.index} key={keyValue} />
}
```

Из примера видно, что данные передаются в дочерний компонент как атрибуты элемента (в примере это атрибуты `index` и `key`), а в дочернем компоненте эти атрибуты заносятся в аргумент `props` который хранит в себе их значения по принципу ключ - значение.

Переходя к нашему проекту компонент `DaySchedule` будет являться одновременно дочерним компонентом для `Schedule` и родительским для `Lesson` т.е. он должен полчить данные от родителя и передать их дочернему компоненту.


Давайте перейдем к нашему расписанию.


## Создание компонента "Schedule"
> Продолжаем работать в файле `src/components/schedule/index.js`

Данный компонент будет показыавть все расписания на день, а так же он будет прокручиваться при "свайпе".

В данном компоненте мы будем использовать `ScrollView`, в котором механизм 'прокрути' реализован библиотекой. 
Внутри данного компонента мы будем показывать расписание за неделю `DaySchedule`.

Мы уже подготовили для вас массив `days` со всеми днями недели, их осталось правильно применить. 
Элементы данного массива - объекты со свойствами:
> `date` - объект даты дня
> `lessons` - занятия за указанный день
> `isHighlighted` - функция, которая указывает, нужно ли подсвечивать занятие

Данные свойства нам и нужно передать в дочерний компонент

Задание: Создайте функцию `renderWeek`, которая будет принимать массив `days` в качестве аргумента и возвращать другой массив с компонентами `DaySchedule`, который должен иметь следующие атрибуты:
> key - служебный атрибут должен быть уникальным, желательно присвоить значение инекса элемента массива
> isHightlighted - присвоить значение `isHighlighted`
> date - `date`
> lessons - `lessons`


Пример функции, которая возврщаает новый массив на основе старого:

```jsx
function example(arr) {
    var newArr = [];

    for (var i = 0; i < arr.length; i++) {
        var arrItem = arr[i];

        newArr.push(arrItem);
    }

    return newArr;
}
```
* для наглядности использован цикл `for`
** новый массив содержит те же элементы, что и 'старый'
*** как использовать компонент внутри функции можно посмотреть в примере с `ParentComponent` и `ChildComponent` 

Как упоминалось ранее, данную функцию нужно использовать внутри `ScrollView`

```jsx
<ScrollView>{ renderWeek(days) }</ScrollView>
```

Давайте проверим результат, но перед этим мы должны проверить, что отображается в компоненте `DaySchedule`
> Откройте файл `src/components/schedule/day-schedule.js`

Как видно, данный компонент возвращает `null`, поэтому сколько бы раз мы его не вызывали, отображаться ничего не будет - заменим его на следующее:
```jsx
export const DaySchedule = (props) => {
    var date = props.date.toString()
    return <Text>{date}</Text>;
}
```

Теперь наш компонент будет всегда возвращать текст с датой. 
Откроем мобильное приложение и посмотрим на результат, должны отображаться строки с датой текущего расписания.

Как это работает? 

Вызывая компонент `Schedule` мы возвращаем контейнер с результатом вызвова функции `renderWeek`, которая в свою очередть возвращает массив компонентов `DaySchedule` т.е. отображает этот компонент то количество раз, сколько элементов у массива `days`. 
Далее каждый вызов компонента `DaySchedule` оуществляется со своими аргументами, которые определяются в `renderWeek`.
В результате мы видим список из дат текущего расписания.


## Создание компонента "DaySchedule"
> Откройте файл `src/components/schedule/day-schedule.js`

Согласитесь, что по значению одной лишь даты, узнать расписание довольно-таки проблематично, поэтому давайте создадим полноценный компонент `DaySchedule`
Данный компонент будет отображать расписания за день. Для этого нужно показать не только дату, но и список занятий.

Сейчас все данные, которые были получены `DaySchedule` находятся в его аргументе
Разберемся какие данные он содержит:

> date - дата дня

> lessons - массив с расписанием на один день, элементы которого являются объектами со свойствами:
    > name - название занятия
    > room - список(массив) аудиторий, где проходит занятие

> isHighlighted - функция (да-да можно и так), которая будет указывать нам, должны ли мы выделить данное занятие или нет


Приступим к созданию компонента:

Для этого нам необходимо заменить текущий функционал на новый:

Для начала создадим контейнер(`View`) с 2 вложенными контейнерами(`View`) в первом мы будем отображать нашу дату, а во втором как раз список занаятий(`Lesson`). 


Задание: создадать функцию `renderDay` по анаолгии с `Schedule` компонентом, которая будет возвращать список компонентов `Lesson`. 
Данная функция будет иметь два аргумента:
> lessons - будем использовать `lessons`, которые мы передаем в качестве одного из свойств аргумента `DaySchedule`
> isHighlighted -аналогично свойству `isHighlighted`

и возвращать новый массив компонентов `Lesson` со следующими атрибутами:
> key - служебный атрибут должен быть уникальным, желательно присвоить значение индекса элемента массива
> index - порядковый номер занятия, берется по аналогии с `key`
> name - принимает значение `name` в элементе массива `lessons`
> rooms - принимает значение `rooms` в эkементе массива `lessons`
> highlight - принимет значения вызова функции isHighlighted, в качестве аргумента передается текущий элемент массива


Тоесть, компонент `Lesson` должен выглядеть примерно так:

```jsx
<Lesson index={ index } name={ lesson.name } rooms={ lesson.rooms } key={ index } highlight={ isHighlighted(props.lesson) } />
```

Теперь используем эту функцию в нужном контейнере и список занятий готов!

Как и в предыдущем компоненте необходимо убедиться, что компонент `Lesson` возвращает результат. 
Откройте файл `src/components/schedule/lesson.js`

и замените текущий функционал на 
```jsx
export const Lesson = (props) => {
    var name = props.name
    return <Text>{name}</Text>;
}
```

Результат отобразиться в мобильном приложениию.
Работает все по той же схеме - данные передаются от родительского компонента к дочерним.

## Создание компонента "Lesson"
> Откройте файл `src/components/schedule/lesson.js`

Данный компонент будет отображать одно занятие и является последним в цепочке родительский - дочерний компоненты, поэтому он будет отвечать за отображение всех данных.

Для этого нам понадобится название предмета, номера аудиторий (их же может быть 2) и порядковый номер. Все эти данные есть в `props` - аргументе нашего компонента, ведь мы передали их в методе `renderDay`. 


Задание:
Добавить "контейнеры" для данных. Создать общий "контейнер" и внутри него еще 3 и заполнить их полученными данными от родительского компонента.
Первый контейнер содержит порядковый номер занятия
Второй - название предмета
Третий - номера аудиторий, за аудитории отвечает свойство `rooms`, которое является массивом чисел(номера аудиторий) - создайте функцию `renderRooms`, которая будет принимать один аргумент - массив с аудиториями. Возращать эта функция будет новый массив, элементы которого будут вида `<Text>{ room }</Text>`.

Ну вот, компонент `Lesson` готов!

Осталось посмотреть на полученный результат. Все компоненты готовы! Вот только выглядит это все очень плохо...

## Стилизация компонентов
Работающее приложение это хорошо, но если оно не красивои не удобно, то все старания впустую. В данной части нашего воркшопа мы будем "разукрашивать" наши компоненты и "ставить на место" элементы.

### Стилизация компонента Schedule
> Откройте файл `src/components/schedule/index.js`

Для начала нам нужно создать описание стилей. Для этого в конце файла создайте переменную `styles`. Эта переменная и будет хранить стили.

Далее нам нужно присвоить этой переменной результат функции `StyleSheet.create`. Передайте в эту функцию пустой объект. В этом пустом объекте создадим свойство `wrapper`, которое будет хранить стили для нашего компонента `ScrollView`. Значением будет объект, у которого будет одно свойство `padding`. Это свойство указывает, что контент внутри компонента должен отстоять от границ компонента на 5 пикселей с каждой стороны.

Должно получиться примерно вот так:
```JavaScript
const styles = StyleSheet.create({
    wrapper: {
        padding: 5,
    },
});
```

Теперь нужно применить созданный стиль на наш компонент. Для этого у компонента `ScrollView` создайте атрибут `style` и присвойте ему значение `styles.wrapper`.
```jsx
<ScrollView style={ styles.wrapper } >...</ScrollView>
```
Можете посмотреть, отступ появился.

Сейчас для данного компонента хватит стилей. В последствии вы сможете сами задать ему стили, например, цвет фона - `backgroundColor`.

### Стилизация компонента DaySchedule
> Откройте файл `src/components/schedule/day-schedule.js`

Здесь, как и у компонента `Schedule`, создайте переменную `styles`. Свойство `padding` можете оставить таким же, а можете изменить. Примените стили `styles.wrapper` на самый внешний компонент `View`.

Добавьте к стилям `wrapper` еще одно - `elevation` со значением 2. Это очень интересное свойство, оно создает эффект "приподнятости" элемента над другими. Хотя если вы сейчас посмотрите на свое приложение, то не увидите разницы. Это все потому, что свойство `elevation` не работает у элементов с прозрачным фоном. Для того, что бы установить фон элемента, к его стилям нужно добавить свойство `backgroundColor` со значением, например, `'white'`.
```JavaScript
const styles = StyleSheet.create({
    wrapper: {
        padding: 5,
        elevation: 2,
        backgroundColor: 'white',
    },
});
```

Теперь опишем стили для "заголовка дня" - даты. Для этого у переменной `styles` создайте новое свойство `header`, внутри которого укажите 2 свойства:
- `fontSize` - размер шрифта. Я бы советовал указать значение `24`
- `fontWeight` - толщина шрифта. Значение `'bold'`

А теперь примените эти стили на компоненте `Text`.

Теперь было бы неплохо как то отодвинуть наши занятия от заголовка. Создадим новое свойство в `styles` с именем `lessonsWrapper`. Там у нас будут стили для 2го вложенного `View`. В этих стилях укажите `padding: 5` и `paddingLeft: 20` и примените эти стили на нужном компоненте.

Свойство `padding` создает отступ с 4 сторон (верх, них, право, лево), а `paddingLeft` задает только слева. Этими 2 свойствами мы сделали отступ слева в 20 пикселей, а сверху, снизу и справа - в 5 пикселей. Этим у нас получился эффект вложенности.

Теперь остался лишь один компонент для стилизации, но он самый сложный.

### Стилизация компонента Lesson
> Откройте файл `src/components/schedule/lesson.js`

Компонент `View` очень близок по отображению к `FlexBox` (`display: flex`) в `CSS`, только он изначально отрисовывется как колонка, а не как строка. именно из-за этой особенности у нас все "поехало". Но сейчас мы все исправим.

Создайте переменную `styles`, аналогично выше.

#### Wrapper
Создайте стили для нашего самого верхнего компонента `View` и сразу примените их на нем.

- Добавьте свойство `flexDirection` со значением `'row'`. Так мы укажем, что бы все элементы внутри были "в строчку"
- Добавьте свойство `flexWrap` со значением `'nowrap'`. Этим мы укажем, что элементы внутри не должны переноситься на новую строку, если не влезут.
- Добавьте свойство `justifyContent` со значением `'flex-start'`. Это свойство укажет, что все элементы должны прижиматься друг к другу и начинаться с начала блока. Другими словами, это свойство указывает распределение элементов по оси направление контейнера
- Добавьте свойство `alignItems` со значением `'stretch'`. Так мы укажем, что бы все элементы внутри должны вытянуться по высоте, что бы занимать всю высоту контейнера. Другими словами, это свойство указывает распределение элементов по оси, перпендикулярной оси направление контейнера

Вот теперь выглядит уже нормально, хотя еще и не совсем красиво. Здесь еще можно добавить слабо заметную границу, что бы было легче следить глазами по строчке. Для этого добавьте свойство `borderBottomWidth` со значением `1`. Это создаст нижнее подчеркивание с толщиной в 1 пиксель. Вот только граница черная, а мы хотели слабо заметную... С помощью свойства `borderColor` можно указать цвет этой границы. Можно использовать значение `'#eee'`, например.

#### Highlight
Вот мы и дошли до стиля `highlight`. Этот стиль будет изменять фон занятия, выделяя его от остальных. Создайте такой стиль у укажите у него свойство `backgroundColor` со значением `'#FAFAD2'`. Теперь осталось лишь его применить.

Для того, что бы объединить стили существует функция `StyleSheet.flatten`. Она принимает единственный аргумент - массив стилей. Используя эту функцию, объедините стили `wrapper` и `highlight` для верхнего компонента `View`.
```jsx
<View style={ StyleSheet.flatten([ styles.wrapper, styles.highlight ]) } >...</View>
```

Теперь у нас занятия подсвечиваются, правда все. Нам нужно добавить условие на применение этого стиля `highlight`. Для этого мы можем использовать тернарное выражение.
`highlight ? styles.highlight : null`.

#### Остальные элементы
Создайте сразу 3 стиля: `index`, `name` и `rooms`. Каждый из этих стилей будет применятся к соответсвующим `View`. Примените эти стили.

У каждого стиля укажите свойство `flexDirection: 'row'` и `alignItems: 'center'`. Таким образом мы все отцентрировали по высоте.

У стилей `index` и `rooms` укажите ширину в 50 и 80 пикселей соответсвенно. За ширину отвечает свойство `width`. Так же у этих стилей укажите свойство `justifyContent` со значение `'center'`.

И остался маленький штрих. Сейчас все элементы прижаты к левому краю, но нам нужно что бы аудитории были с правого края. Для этого есть свойство `flex`. Это свойство указывает, как должен растягивать/сжиматься элемент, чтобы заполнить пространство. По умолчанию `flex` имеет значение 0, что означает, что элемент не тянется/не сжимается. Установите это свойство в `1`, и тогда все встанет на свои места.

Вот и все, мы закончили со стилями. Если хотите, можете с ними "поиграться". ☺
