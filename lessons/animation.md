# Анимация в `React Native`

В этом задании мы с вами добавим анимацию для компонента `Popup` - всплывающее окошко с настройками. Вы уже его видели при старте приложения.
Что бы его вызвать, можно нажать на значек шестеренки в правом верхнем углу приложения.

Сейчас этот компонент просто появляется на экране и его затеняющий фон тоже статичен. Мы с вами добавим движение при его открытии и закрытии, а так же сделаем изменение интенсивности затенения.

Но сначала теория.

## Теория

### Классовые компоненты
До этого вы познакомились с реализацией компонентов через функции. Функциональные компоненты удобны - они короткие и они быстрее работают. Но иногда нужно использовать внутреннее состояние в компоненте или делать что то в момент, когда компонент только появился или удалился. Для этого используются "классические" компоненты - компоненты-классы.

У таких компонентов `props` уже находится в свойствах объекта и получить доступ к ним можно через `this.props`. Так же у этих компонентов есть внутреннее состояние - `this.state`. Если изменится либо `props`, либо `state`, то компонент будет перерисовываться. 

`state` это обычный объект, в котором есть данные, вот только менять его нельзя как обычный объект - изменения не подцепятся. Для изменений `state` существует специальныя функция `this.setState`, в которую мы передадим изменения, и они применятся. Но я подготовил занятие так, что бы вам не пришлось изменять `state`.

И последнее, про что стоит здесь упомянуть - это "LifeCycle Hooks" компонента. Если говорить просто, то это функции, которые будут вызываться при определенных условиях. Здесь я бы хотел вас познакомить лишь с одним из них - `componentWillReceiveProps(newProps)`. Данная функция вызывается каждый раз, когда у компонента изменились `props`. Мы это уже используем для того, что бы запускать определенные функции: показ и сокрытые компонента.

### Что такое анимация

Анимация - это всего лишь изменение внешнего вида с каждым изменением кадра. Другими словами, если мы в течении нескольких подряд идущих кадров будем плавно менять картинки, то нам будет казаться, что оно движется. Яркий пример - GIF файлы. Там просто картинка сменяет картинку.

В нашем случае нам не обязательно строить каждый кадр самим, за нас это сделает `React Native`. Нам лишь понадобится менять какие то параметры каждый кадр.

### Библиотека `Animated`

В `React Native` для анимации сделана специальная библиотека `Animated`. Эта библиотека имеет несколько очень нужных классов, а так же компонентов, которые будут анимированны.

> Технически, библиотка `Animation` не является библиотекой, скорей это `namespace`, но для простоты я буду называть ее библиотекой

#### `Animated.View`

Этот компонент по сути своей обычный компонент `View`, с которым вы работали раньше. Но в отличае от `View`, `Animated.View` умеет использовать объекты настройки анимации к значение стиля. Если же мы этот объект настройки анимации используем на обычном `View`, то у нас будет ошибка.

Всего в данной библиотеке есть 4 готовых анимированных компонента:
1. `Animated.Image`
2. `Animated.ScrollView`
3. `Animated.Text`
4. `Animated.View`

#### `Animated.Value`
Это конструктор объекта, который будет хранить состояние анимации. Мы можем использовать его значение, для анимирования компонента или мы можем воспользоваться интерполяцией, для получения необходимых значений.

#### `Easing`
Это еще одна библиотека в `React Native`. В данный библиотеке находятся функции анимации, например, `Easing.ease` - анимация, когда сначала есть эффект "разгона", а под конец - "торможения". Именно эту функцию мы и будем использовать.

#### Интерполяция
Интерполяция - это процесс перевода значения из одной шкалы в другую. Например, у нас есть шкала от 0 до 1 и на ней отмечена точка 0.5. Тогда если мы это значение 0.5 интерполируем на другую шкалу, например от 0 до 10, то мы получим значение 5, потому что 5 на новой шкале находится в той же позиции, что и 0.5 для изначальной шкалы.

Ну хватит теории, давайте приступим!

## Анимирование открытия и закрытия компонента `Popup`
> Откройте файл [./../src/components/popup/index.js](./../src/components/popup/index.js)

Перед вами компонент `Popup`. Он может показаться очень большим, но не пугайтесь, здесь нам понадобится дописать не так много.

Для начала перейдите в конструктор (`constructor`). Здесь вы можете увидеть строчку инициализации переменной `this.state`. Как вы уже догадались - это инициализация нашего `state` компонента. В него нам нужно добавить наше анимированное значение. Для этого добавьте в объект `this.state` новое значение `animatedValue` и приравняйте его к `new Animated.Value(0)`. Но у нас не обязательно, что этот компонент всегда сразу закрыт. Для того, что бы компонент сам решал, открыт ли он или закрыт, мы применим тернарное выражение для инициализации начальное значения.

```javascript
state = {
    animationValue: new Animated.Value(props.opened ? 1 : 0),
    isDisplayed: props.opened,
}
```

Отлично, мы создали значение анимации, теперь нужно создать саму анимацию.

Для создания анимации в конце функции `construct` создайте переменную `this.animationOpen` и приравняйте ее к результату функции `Animated.timing()`. Анимация создана, но не настроена. Передайте в функцию `Animated.timing()` первым аргументом наше значение `this.state.animationValue`, а вторым - пустой объект. Через этот объект мы и будем настраивать анимацию.

```javascript
this.animationOpen = Animated.timing(
    this.state.animationValue,
    {

    }
);
```

В данном объекте нам нужно указать 3 параметра:
- `easing` - функция анимации. Мы будем использовать `Easing.ease`
- `duration` - время анимации. Это время в течении которого наша анимация будет стремиться к конечному значения. Значением этого параметра будет число милисекунд, например, `500`
- `toValue` - значение, к которому будет стремиться анимация. Тоесть, в конце анимации наша переменная `this.state.animationValue` будет иметь это значение. Установите его в `1`

У вас должно получиться так:
```javascript
this.animationOpen = Animated.timing(
    this.state.animationValue,
    {
        easing: Easing.ease,
        duration: 200,
        toValue: 1,
    }
);
```

А теперь сами создайте анимация закрытия `this.animationOpen`. Она будет отличаться лишь конечным значением (`0`)

Для того, что бы видеть измениния, нам нужно "привязать" наше значение к стилям. Для этого найдите функцию `render` и в ней замените
```javascript
const backdropStyles = StyleSheet.flatten([
    styles.backdrop,
    { opacity: 0.7 },
]);
```
на
```javascript
const backdropStyles = StyleSheet.flatten([
    styles.backdrop,
    { opacity: this.state.animationValue },
]);
```

И так мы будем видеть измениние затенения фона при анимации.

Теперь мы займемся запуском анимаций.

Найдите в этом файле функцию `handleOpen`. Эта функция вызывается каждый раз, когда наш компонент должен показаться. Сейчас компонент появляется мгновенно, но мы это исправим. Для начала нам необходимо убедиться, что никакая другая анимация не работает. В начале этой функции добавьте остановку анимаций

```javascript
this.state.animationValue.stopAnimation();
```

А теперь нужно запустить анимацию. Для этого в конце функции добавить строчку

```javascript
this.animationOpen.start();
```

Вот и все, все просто!

С анимацией закрытия немного сложней, но совсем немного. Найдите функцию `handleClose` и добавьте остановку анимации в начало. Так же добавитьте запуск анимации закрытия в конце, по примеры выше. А теперь начинается отличие.

Если все оставить как сейчас написано, то на зарытии у нас анимация не срабатывает. На самом деле это не так, просто мы не видим этого, потому что скрываем компонент сразу, а не дожидаемся окончания анимации. Нам нужно выполнить строчку `this.setState({ isDisplayed: true });` после анимации. Для этого мы можем передать функцию как аргумент в функцию старта анимации. Должно получиться так:

```javascript
handleClose = () => {
    this.state.animationValue.stopAnimation();
    this.animationClose.start(() => this.setState({ isDisplayed: false }));
}
```
И вот теперь у нас все работает!

Теперь заставим двигаться наше всплывающее окошко.

Для этого перейдем в функцию `render`. Там есть объеинение стилей в переменной `popupStyles`. Именно в этой переменной нам нужно указать значение анимации. Замените значение этой переменной на следующее:

```javascript
const popupStyles = StyleSheet.flatten([
    styles.popup,
    { transform: [{ translateY: this.state.animationValue }]}
]);
```

Видите анимацию? А она есть! Правда всего в 1 пиксель... Нам нужно как то увеличить амплитуду движения. Для этог омы будем использовать интерполяцию.

Создайте над переменной `const popupStyles` новую - `transformInterpolation`.

У нашего значения `this.state.animationValue` есть метод `interpolate`. В этот метод нужно передать как аргумент объект, в котором в поле `inputRange` будет изначальная шкала, а в `outputRange` - конечная. На самом деле, туда можно передать произвольную шкалу, довольно сложной формы, но нам хватит лишь начальной и конечной точек. В `inputRange` укажите массив `[0, 1]` (от 0 до 1), а в `outputRange` - `[height, 0]`
> `height` - это переменная, объявленная чуть выше, в начале функции. В этой переменной хранится высота экрана.

```javascript
const transformInterpolation = this.state.animationValue.interpolate({
    inputRange: [0, 1],
    outputRange: [height, 0],
});
```

И теперь замените в переменной `popupStyles` значение `this.state.animationValue` на переменную интерполяции.

```javascript
const popupStyles = StyleSheet.flatten([
    styles.popup,
    { transform: [{ translateY: transformInterpolation }]}
]);
```

В общем, все. Но для тренеровки вы можете сделать свою собственную интерполяцию для прозрачности затенения заднего фона. Для этого конченая шкала интерполяции должна начинаться с `0`, а заканчиваться каим то значением в промежутке от `0` до `1`. Мне, например, нравится как выглядит при максимальном значении `0.7`. Создайте новую переменную интерполии, настройте ее и примените в переменной `backdropStyles`.

Вот теперь точно все!